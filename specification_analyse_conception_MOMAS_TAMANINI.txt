Gestion d'une boutique de vêtements en ligne 

//Remplir une ligne de la table utilisateur
INSERT INTO utilisateur (id_utilisateur#, nom_utilisateur, prenom_utilisateur, adresse_utilisateur, email_utilisateur) VALUES (1, 'Spears', 'Britney', '65 avenue de Hollywood', 'b.spears@gmail..com');

DESCRIPTION DU SUJET:
Nous avons choisis de réaliser un Système de Gestion de Base de Donnée d'un magasin de vêtement en ligne. Ce système de gestion doit pouvoir réaliser les missions suivantes afin de garantir un achat et une livraison correct sur le site de vêtement:


- Comptes utilisateur (création de compte)

- Gestion des commandes (passées par le client)

- Tri des vêtements par catégorie afin d'améliorer la recherche des vêtements

- Ajout, modification, suppression de vêtements (back office) 

Service :  

- Front office : vente des vêtements / création - connexion compte  

- Back office : ajout, modification, suppression des vêtements / gestion des expéditions 


DICTIONNAIRE DE DONNEES MERISE

description textuelles des associations

Nous avons 6 tables dans notre SGBD eshop. Parmis cela, nous avons la table vêtement qui contient les noms, id, descriptions, prix et quantité du vêtement. 
Ces vêtements sont choisis par un utilisateur. Nous avons donc une association Utilisateur -- Choisit -- vetement.
Un utilisateur peut choisir entre 0 à n vêtements.

L'utilisateur, après avoir choisi ses vetements, peut passer une ou plusieurs commandes.

Les vêtements ont aussi des caractéristiques telles qu'une categorie, une taille, une couleur. Nous avons définis pour optimiser la recherche sur le SGBD 1 catégorie, 1 taille et 1 couleur pour 1 vetement.
Une categorie peut avoir plusieurs tailles, de même que plusieurs couleurs. La visualisation des couleurs de vêtement pourra se faire que lorsqu'on filtre les vetements par catégorie ou lorsqu'on applique aucun filtre. Nous partons du principe que pour chercher un vetement d'une certaine taille, il faut chercher par categorie de vêtement.

Si il n'y a plus de vêtements en stock dans la table vetement (caractérisé par son attribut quantite_vetement), des vetements sont commandés pour reapprovisionner le stock.


PACKAGE

Les blocs packages:

CREATE OR REPLACE PACKAGE UTILISATEUR_PACKAGE AS 

FUNCTION UTILISATEURinserer(userId IN number, userLastName IN VARCHAR2, userFirstName IN VARCHAR2, userAddress IN VARCHAR2, userEmail IN VARCHAR2 , userPassword IN VARCHAR2)
return NUMBER ;
--FUNCTION UTILISATEURtotal()
--return NUMBER IS total NUMBER;

PROCEDURE UTILISATEURsupprimer(userId IN number);
PROCEDURE UTILISATEURmodifierMotDePasse(userId IN number, userPassword IN VARCHAR2);
PROCEDURE UTILISATEURmodifierNom(userId IN number, userLastName IN VARCHAR2, userFirstName IN VARCHAR2);
PROCEDURE UTILISATEURlister;
PROCEDURE UTILISATEURdepensesUtilisateurs();
PROCEDURE UTILISATEURCommandeDeclinaison(idDeclinaison IS NUMBER);
PROCEDURE UTILISATEURCommandeAnnulee();


END UTILISATEUR_PACKAGE;

CREATE OR REPLACE PACKAGE COMMANDE_PACKAGE AS 

FUNCTION COMMANDEinserer(commandeId IN number, etatCommande IN VARCHAR2, prixCommande IN number)
return NUMBER ;
PROCEDURE COMMANDEsupprimer(commandeId IN number);
PROCEDURE COMMANDEmodifierPrixCommande(commandeId IN number, prixCommande IN NUMBER);
PROCEDURE COMMANDEmodifierEtatCommande(commandeId IN number, etatCommande IN VARCHAR2);
PROCEDURE COMMANDElister(userId);

END COMMANDE_PACKAGE;


Les packages body:
CREATE OR REPLACE
PACKAGE BODY UTILISATEUR_PACKAGE AS

  FUNCTION UTILISATEURinserer(userId IN number, userLastName IN VARCHAR2, userFirstName IN VARCHAR2, userAddress IN VARCHAR2, userEmail IN VARCHAR2 , userPassword IN VARCHAR2)
return NUMBER  AS
BEGIN
    INSERT INTO UTILISATEUR
     VALUES(userId, userLastName, userFirstName, userAddress, userEmail, userPassword);
	RETURN (userId);
  END UTILISATEURinserer;

END UTILISATEUR_PACKAGE;


--Spécification des traitement avec des packages PLSQL (Modèle de traitements)
--. Choisir parmi vos tables deux d’entres (A et B) elles sur lesquelles les fonctions suivantes 
--vont être spécifiées puis implémentées :


--Sur la table A, définir un package plsql ayant le nom de la dite table:

CREATE OR REPLACE
PACKAGE BODY UTILISATEUR_PACKAGE AS

-- - ajouter une nouvelle occurence à A : fonction Ainserer;

FUNCTION UTILISATEURinserer(userId IN number, userLastName IN VARCHAR2, userFirstName IN VARCHAR2, userAddress IN VARCHAR2, userEmail IN VARCHAR2 , userPassword IN VARCHAR2)
return NUMBER AS
BEGIN
INSERT INTO UTILISATEUR-
VALUES(userId, userLastName, userFirstName, userAddress, userEmail, userPassword);
RETURN (userId);
END UTILISATEURinserer;


-- - supprimer une occurrence à A (Attention : les enregistrements liés dans B doivent 
--aussi être supprimés) : fonction Asupprimer;

PROCEDURE UTILISATEURsupprimer(userId IN number)
BEGIN
DELETE FROM UTILISATEUR
WHERE ID_UTILISATEUR = userId; 
END UTILISATEURsupprimer;


-- - modifier des informations sur de A : fonction AmodifierF1, AmodifierF2 
--(texte requêtes correspondantes plus haut);

PROCEDURE UTILISATEURmodifierMotDePasse(userId IN number, userPassword IN VARCHAR2)
BEGIN
UPDATE UTILISATEUR
SET MDP_UTILISATEUR = userPassword
WHERE ID_UTILISATEUR = userId; 
END UTILISATEURmodifierMotDePasse;

PROCEDURE UTILISATEURmodifierNom(userId IN number, userLastName IN VARCHAR2, userFirstName IN VARCHAR2)
BEGIN
UPDATE UTILISATEUR
SET NOM_UTILISATEUR = userLastName, PRENOM_UTILISATEUR = userFirstName 
WHERE ID_UTILISATEUR = userId; 
END UTILISATEURmodifierNom;


-- - lister toutes les occurrences de A: fonction Alister;

PROCEDURE UTILISATEURlister()
DECLARE
CURSOR user_list IS SELECT *
FROM UTILISATEUR;

userId UTILISATEUR.ID_UTILISATEUR%TYPE;
userLastName UTILISATEUR.NOM_UTILISATEUR%TYPE;
userFirstName UTILISATEUR.PRENOM_UTILISATEUR%TYPE;
userAddress UTILISATEUR.ADRESSE_UTILISATEUR%TYPE;
userEmail UTILISATEUR.EMAIL_UTILISATEUR%TYPE;
userPassword UTILISATEUR.MDP_UTILISATEUR%TYPE;
BEGIN
OPEN user_list;
LOOP
FETCH user_list INTO userId,userLastName,userFirstName,userAddress,userEmail,userPassword;
DBMS_OUTPUT.PUT_LINE(userId || ' - ' || userLastName || ' - ' || userFirstName || ' - ' || userAddress ||' - ' || userEmail ||' - ' || userPassword);
END LOOP;
END UTILISATEURlister;

-- - fournir le nombre total des occurrences de A : fonction Atotal ;

FUNCTION UTILISATEURtotal()
return NUMBER IS total NUMBER;
BEGIN
SELECT COUNT(*) INTO total
FROM UTILISATEUR
RETURN (total);
END UTILISATEURtotal;


-- - Proposer aussi 3 fonctions avec des requêtes de consultation impliquant 2 ou 3 
-- tables au moins (jointure, groupe, tri) : fonction Af1, Af2, Af3. f1, f2, f3 sont
-- des noms à définir AmodifierF2 (texte requêtes correspondantes plus haut);

PROCEDURE UTILISATEURdepensesUtilisateurs()
DECLARE
CURSOR depenseUtilisateur IS 
SELECT UTILISATEUR.NOM_UTILISATEUR, UTILISATEUR.PRENOM_UTILISATEUR, SUM(COMMANDE.PRIX_COMMANDE)
FROM UTILISATEUR 
JOIN COMMANDE ON COMMANDE.ID_UTILISATEUR = UTILISATEUR.ID_UTILISATEUR
GROUP BY UTILISATEUR.ID_UTILISATEUR;

userLastName UTILISATEUR.NOM_UTILISATEUR%TYPE;
userFirstName UTILISATEUR.PRENOM_UTILISATEUR%TYPE;
sommeCommandes COMMANDE.PRIX_COMMANDE%TYPE;

BEGIN
OPEN depenseUtilisateur;
LOOP
FETCH depenseUtilisateur INTO userLastName,userFirstName,sommeCommandes;
DBMS_OUTPUT.PUT_LINE(userLastName || ' - ' || userFirstName || ' : ' || sommeCommandes);
END LOOP;
END UTILISATEURdepensesUtilisateurs;

PROCEDURE UTILISATEURCommandeDeclinaison(idDeclinaison IS NUMBER)
DECLARE
CURSOR user_list IS 
SELECT UTILISATEUR.*
FROM UTILISATEUR
JOIN COMMANDE ON COMMANDE.ID_UTILISATEUR = UTILISATEUR.ID_UTILISATEUR
JOIN EST_COMMANDE ON EST_COMMANDE.ID_COMMANDE = COMMANDE.ID_COMMANDE
WHERE EST_COMMANDE.ID_DECLINAISON = idDeclinaison;

userId UTILISATEUR.ID_UTILISATEUR%TYPE;
userLastName UTILISATEUR.NOM_UTILISATEUR%TYPE;
userFirstName UTILISATEUR.PRENOM_UTILISATEUR%TYPE;
userAddress UTILISATEUR.ADRESSE_UTILISATEUR%TYPE;
userEmail UTILISATEUR.EMAIL_UTILISATEUR%TYPE;
userPassword UTILISATEUR.MDP_UTILISATEUR%TYPE;
BEGIN
OPEN user_list;
LOOP
FETCH user_list INTO userId,userLastName,userFirstName,userAddress,userEmail,userPassword;
DBMS_OUTPUT.PUT_LINE(userId || ' - ' || userLastName || ' - ' || userFirstName || ' - ' || userAddress ||' - ' || userEmail ||' - ' || userPassword);
END LOOP;
END UTILISATEURCommandeDeclinaison;

PROCEDURE UTILISATEURCommandeAnnulee()
DECLARE
CURSOR user_list IS SELECT UTILISATEUR.*
FROM UTILISATEUR
JOIN COMMANDE ON COMMANDE.ID_UTILISATEUR = UTILISATEUR.ID_UTILISATEUR
WHERE COMMANDE.ETAT_COMMANDE = 'Annulee';

userId UTILISATEUR.ID_UTILISATEUR%TYPE;
userLastName UTILISATEUR.NOM_UTILISATEUR%TYPE;
userFirstName UTILISATEUR.PRENOM_UTILISATEUR%TYPE;
userAddress UTILISATEUR.ADRESSE_UTILISATEUR%TYPE;
userEmail UTILISATEUR.EMAIL_UTILISATEUR%TYPE;
userPassword UTILISATEUR.MDP_UTILISATEUR%TYPE;
BEGIN
OPEN user_list;
LOOP
FETCH user_list INTO userId,userLastName,userFirstName,userAddress,userEmail,userPassword;
DBMS_OUTPUT.PUT_LINE(userId || ' - ' || userLastName || ' - ' || userFirstName || ' - ' || userAddress ||' - ' || userEmail ||' - ' || userPassword);
END LOOP;
END UTILISATEURCommandeAnnulee;


END UTILISATEUR_PACKAGE;








--Sur la table B, définir un package plsql ayant le nom de la dite table:
CREATE OR REPLACE PACKAGE UTILISATEUR_PACKAGE AS
FUNCTION COMMANDEinserer(commandeId IN number, etatCommande IN VARCHAR2, prixCommande IN number)
return NUMBER AS
BEGIN
INSERT INTO UTILISATEUR-
VALUES(commandeId, etatCommande, prixCommande);
RETURN (commandeId);
END COMMANDEinserer;

-- supprimer une occurrence à B : fonction Bsupprimer;
PROCEDURE COMMANDEsupprimer(commandeId IN number)
BEGIN
DELETE FROM COMMANDE
WHERE ID_COMMANDE = commandeId; 
END COMMANDEsupprimer;
-- modifier des informations sur de B : fonction BmodifierF1, BmodifierF2

PROCEDURE COMMANDEmodifierPrixCommande(commandeId IN number, prixCommande IN NUMBER)
BEGIN
UPDATE COMMANDE
SET PRIX_COMMANDE = prixCommande
WHERE ID_COMMANDE = commandeId; 
END COMMANDEmodifierPrixCommande;

PROCEDURE COMMANDEmodifierEtatCommande(commandeId IN number, etatCommande IN VARCHAR2)
BEGIN
UPDATE COMMANDE
SET ETAT_COMMANDE = etatCommande 
WHERE ID_COMMANDE = commandeId; 
END COMMANDEmodifierEtatCommande;

- lister toutes les occurrences de B pour une occurrence de A donnée: fonction Blister
--*****************************************
PROCEDURE COMMANDElister(userId)
DECLARE
CURSOR commande_list IS SELECT * // peut être mettre ici une condition de tableau A ?
FROM COMMANDE;

commandeId COMMANDE.ID_COMMANDE%TYPE;
commandeEtatCommande COMMANDE.ETAT_COMMANDE%TYPE;
commandePrixCommande COMMANDE.PRIX_COMMANDE%TYPE;
BEGIN
OPEN commande_list; 
LOOP
FETCH commande_list INTO commandeId, commandeEtatCommande, commandePrixCommande;
If UTILISATEUR.ID_UTILISATEUR =  userId
              DBMS_OUTPUT.PUT_LINE(commandeId || ' - ' || commandeEtatCommande || ' - ' || commandePrixCommande);        
END if ;
END LOOP;
END COMMANDElister;

